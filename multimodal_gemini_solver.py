#!/usr/bin/env python3
"""
R√©solveur Captcha Multimodal avec Gemini Flash (Image + Audio)
"""
import glob
import os
from typing import List, Optional, Tuple
import logging
import google.generativeai as genai
from dotenv import load_dotenv

logger = logging.getLogger(__name__)

load_dotenv()


class MultimodalGeminiSolver:
    """R√©solveur captcha multimodal avec Gemini Flash"""

    def __init__(self):
        self.api_key = os.getenv('GEMINI_API_KEY')
        if not self.api_key:
            raise ValueError("GEMINI_API_KEY doit √™tre configur√© dans .env")

        genai.configure(api_key=self.api_key)

        # Liste prioritaire de mod√®les (s√©par√©s par des virgules) configurable via .env
        # Ajouter ici les mod√®les recommand√©s en fallback pour √©viter le rate limiting
        # Priorit√© demand√©e : meilleure qualit√© puis fallback moins puissants
        default_priority = (
            "gemini-2.5-flash,gemini-2.0-flash-exp,gemini-2.0-flash,gemini-2.5-flash-lite,gemini-2.0-flash-lite,gemini-2.5-pro"
        )

        priority_env = os.getenv('GEMINI_MODEL_PRIORITY', default_priority)
        models = [m.strip() for m in priority_env.split(',') if m.strip()]

        self.model_candidates: List[Tuple[str, genai.GenerativeModel]] = []
        for model_name in models:
            try:
                candidate_model = genai.GenerativeModel(model_name)
                self.model_candidates.append((model_name, candidate_model))
                logger.info(f"‚úÖ Mod√®le Gemini disponible: {model_name}")
            except Exception as err:
                logger.warning(f"‚ö†Ô∏è Impossible d'initialiser le mod√®le {model_name}: {err}")

        if not self.model_candidates:
            raise RuntimeError(
                "Aucun mod√®le Gemini disponible parmi la liste de priorit√©. V√©rifiez GEMINI_API_KEY et GEMINI_MODEL_PRIORITY"
            )

        self._preferred_index = 0
        self.model_name, self.model = self.model_candidates[self._preferred_index]

        multimodal_env = os.getenv('GEMINI_MULTIMODAL_MODELS')
        if multimodal_env:
            self._multimodal_whitelist = {m.strip() for m in multimodal_env.split(',') if m.strip()}
        else:
            self._multimodal_whitelist = None

        self.supports_multimodal = self._model_supports_multimodal(self.model_name)

        logger.info(f"üîç Support multimodal: {self.supports_multimodal} (mod√®le: {self.model_name})")
        if len(self.model_candidates) > 1:
            fallback_names = ', '.join(name for name, _ in self.model_candidates[1:])
            if fallback_names:
                logger.info(f"‚û°Ô∏è Fallbacks disponibles: {fallback_names}")

    def is_available(self) -> bool:
        """V√©rifie si Gemini est disponible"""
        return bool(self.api_key)

    def solve_captcha_multimodal(self, image_path: str, audio_path: str) -> Optional[str]:
        """
        R√©sout un captcha en utilisant image ET audio simultan√©ment

        Args:
            image_path: Chemin vers l'image captcha
            audio_path: Chemin vers l'audio captcha

        Returns:
            Code captcha r√©solu ou None
        """
        image_data = self._prepare_image(image_path)
        if not image_data:
            return None

        audio_data = self._prepare_audio(audio_path)
        if not audio_data:
            return None

        prompt = self._create_multimodal_prompt()
        last_error: Optional[Exception] = None

        for index, (model_name, model_instance) in self._iterate_candidates():
            supports_multimodal = self._model_supports_multimodal(model_name)
            if not supports_multimodal:
                logger.info(f"‚è≠Ô∏è Mod√®le {model_name} ignor√© (pas de support multimodal d√©clar√©)")
                continue

            logger.info(f"ü§ñ Analyse multimodale avec mod√®le '{model_name}': {image_path} + {audio_path}")

            try:
                response = model_instance.generate_content([prompt, image_data, audio_data])
                text = getattr(response, 'text', None)
                if not text:
                    logger.warning(f"‚ùå Pas de r√©ponse de Gemini pour le mod√®le {model_name}")
                    continue

                captcha_code = self._clean_response(text)
                logger.info(f"‚úÖ Gemini multimodal (mod√®le {model_name}): '{captcha_code}'")
                self._set_active_model(index, supports_multimodal)
                return captcha_code

            except Exception as error:
                last_error = error
                if self._is_rate_limit_error(error):
                    logger.warning(f"‚è≥ Rate limit sur le mod√®le {model_name}, essai du suivant")
                    continue

                logger.error(f"‚ùå Erreur Gemini multimodal ({model_name}): {error}")
                continue

        if last_error:
            logger.error(f"‚ùå Tous les mod√®les multimodaux ont √©chou√©. Derni√®re erreur: {last_error}")
        else:
            logger.error("‚ùå Aucun mod√®le multimodal n'a pu r√©pondre.")
        return None

    def solve_captcha_image_only(self, image_path: str, image_data=None) -> Optional[str]:
        """R√©solution image seule (fallback)"""
        try:
            if image_data is None:
                image_data = self._prepare_image(image_path)
            if not image_data:
                return None

            prompt = self._create_image_prompt()
            last_error: Optional[Exception] = None

            for index, (model_name, model_instance) in self._iterate_candidates():
                logger.info(f"üñºÔ∏è R√©solution image-only avec mod√®le '{model_name}'")
                try:
                    response = model_instance.generate_content([prompt, image_data])
                    text = getattr(response, 'text', None)
                    if not text:
                        logger.warning(f"‚ùå Pas de r√©ponse de Gemini pour le mod√®le {model_name}")
                        continue

                    captcha_code = self._clean_response(text)
                    logger.info(f"‚úÖ Gemini image (mod√®le {model_name}): '{captcha_code}'")
                    supports_multimodal = self._model_supports_multimodal(model_name)
                    self._set_active_model(index, supports_multimodal)
                    return captcha_code

                except Exception as error:
                    last_error = error
                    if self._is_rate_limit_error(error):
                        logger.warning(f"‚è≥ Rate limit sur le mod√®le {model_name}, essai du suivant")
                        continue

                    logger.error(f"‚ùå Erreur Gemini image ({model_name}): {error}")
                    continue

            if last_error:
                logger.error(f"‚ùå Tous les mod√®les image-only ont √©chou√©. Derni√®re erreur: {last_error}")
            else:
                logger.error("‚ùå Aucun mod√®le n'a pu traiter l'image.")
            return None

        except Exception as error:
            logger.error(f"‚ùå Erreur Gemini image: {error}")
            return None

    def solve_captcha_audio_only(self, audio_path: str, audio_data=None) -> Optional[str]:
        """R√©solution audio seule (fallback)"""
        try:
            if audio_data is None:
                audio_data = self._prepare_audio(audio_path)
            if not audio_data:
                return None

            prompt = self._create_audio_prompt()
            last_error: Optional[Exception] = None

            for index, (model_name, model_instance) in self._iterate_candidates():
                supports_multimodal = self._model_supports_multimodal(model_name)
                if not supports_multimodal:
                    logger.info(f"‚è≠Ô∏è Mod√®le {model_name} ignor√© (pas de support multimodal d√©clar√©)")
                    continue

                logger.info(f"üéß R√©solution audio-only avec mod√®le '{model_name}'")
                try:
                    response = model_instance.generate_content([prompt, audio_data])
                    text = getattr(response, 'text', None)
                    if not text:
                        logger.warning(f"‚ùå Pas de r√©ponse de Gemini pour le mod√®le {model_name}")
                        continue

                    captcha_code = self._clean_response(text)
                    logger.info(f"‚úÖ Gemini audio (mod√®le {model_name}): '{captcha_code}'")
                    self._set_active_model(index, supports_multimodal)
                    return captcha_code

                except Exception as error:
                    last_error = error
                    if self._is_rate_limit_error(error):
                        logger.warning(f"‚è≥ Rate limit sur le mod√®le {model_name}, essai du suivant")
                        continue

                    logger.error(f"‚ùå Erreur Gemini audio ({model_name}): {error}")
                    continue

            if last_error:
                logger.error(f"‚ùå Tous les mod√®les audio-only ont √©chou√©. Derni√®re erreur: {last_error}")
            else:
                logger.error("‚ùå Aucun mod√®le n'a pu traiter l'audio.")
            return None

        except Exception as error:
            logger.error(f"‚ùå Erreur Gemini audio: {error}")
            return None

    def _iterate_candidates(self):
        """It√®re sur les candidats en commen√ßant par le mod√®le pr√©f√©r√©."""
        total = len(self.model_candidates)
        for offset in range(total):
            index = (self._preferred_index + offset) % total
            yield index, self.model_candidates[index]

    def _set_active_model(self, index: int, supports_multimodal: bool) -> None:
        """M√©morise le mod√®le actif apr√®s un succ√®s."""
        self._preferred_index = index
        self.model_name, self.model = self.model_candidates[index]
        self.supports_multimodal = supports_multimodal

    def _model_supports_multimodal(self, model_name: str) -> bool:
        """Indique si un mod√®le supporte image+audio selon la configuration."""
        if self._multimodal_whitelist is None:
            return True
        return model_name in self._multimodal_whitelist

    @staticmethod
    def _is_rate_limit_error(error: Exception) -> bool:
        """D√©tecte les erreurs li√©es au rate limit pour d√©clencher un fallback."""
        keywords = (
            "rate limit",
            "quota",
            "429",
            "resource exhausted",
            "too many requests",
        )
        message = str(error).lower()
        if any(keyword in message for keyword in keywords):
            return True

        code = getattr(error, 'code', None)
        if code in (429, '429'):
            return True

        status = getattr(error, 'status', None)
        if status in (429, 'RESOURCE_EXHAUSTED', 'TOO_MANY_REQUESTS'):
            return True

        status_code = getattr(error, 'status_code', None)
        if status_code in (429, '429'):
            return True

        try:
            from google.api_core import exceptions as google_exceptions
            if isinstance(error, (google_exceptions.ResourceExhausted, google_exceptions.TooManyRequests)):
                return True
        except Exception:
            # google.api_core peut ne pas √™tre pr√©sent ou ne pas exposer ces exceptions
            pass

        return False

    def _prepare_image(self, image_path: str):
        """Pr√©pare les donn√©es image pour Gemini"""
        try:
            from PIL import Image

            # Charger l'image avec PIL
            image = Image.open(image_path)

            return image

        except Exception as e:
            print(f"‚ùå Erreur pr√©paration image: {e}")
            return None

    def _prepare_audio(self, audio_path: str):
        """Pr√©pare les donn√©es audio pour Gemini"""
        try:
            # Pour Gemini 2.5 Flash, on peut passer le chemin directement
            with open(audio_path, 'rb') as f:
                audio_data = f.read()

            # Cr√©er un objet compatible avec l'API
            return {
                "mime_type": "audio/wav",
                "data": audio_data
            }

        except Exception as e:
            print(f"‚ùå Erreur pr√©paration audio: {e}")
            return None

    def _create_multimodal_prompt(self) -> str:
        """Prompt optimis√© pour analyse multimodale"""
        return """Tu re√ßois un captcha de s√©curit√© d'un site gouvernemental fran√ßais sous DEUX FORMATS:
1. Une IMAGE avec du texte d√©form√©
2. Un AUDIO qui √©nonce le m√™me code

INSTRUCTIONS CRITIQUES:
- Analyse SIMULTANEMENT l'image ET l'audio
- Le code contient UNIQUEMENT des lettres (a-z, A-Z) et des chiffres (0-9)
- Aucun symbole, espace ou caract√®re sp√©cial
- Longueur typique: 5-8 caract√®res
- Utilise les deux sources pour CONFIRMER le code exact

PROCESSUS:
1. Lis le texte dans l'image (malgr√© la d√©formation)
2. √âcoute l'audio et transcris ce qui est √©nonc√©
3. Compare les deux r√©sultats
4. Si concordance ‚Üí r√©ponds avec ce code
5. Si diff√©rence ‚Üí utilise la source la plus claire

R√âPONSE:
R√©ponds UNIQUEMENT avec le code captcha, rien d'autre.
Exemple: K93TDRK

Code captcha:"""

    def _create_image_prompt(self) -> str:
        """Prompt optimis√© pour image seule"""
        return """Tu re√ßois un captcha de s√©curit√© d'un site gouvernemental fran√ßais.

CONTRAINTES STRICTES:
- Le code contient UNIQUEMENT des lettres (a-z, A-Z) et des chiffres (0-9)
- Aucun symbole, espace ou caract√®re sp√©cial
- Longueur typique: 5-8 caract√®res
- Ignore toute d√©formation visuelle

Lis attentivement le texte dans cette image d√©form√©e.

R√âPONSE:
R√©ponds UNIQUEMENT avec le code captcha, rien d'autre.
Exemple: V54LpY

Code captcha:"""

    def _create_audio_prompt(self) -> str:
        """Prompt optimis√© pour audio seule"""
        return """Tu re√ßois un captcha audio d'un site gouvernemental fran√ßais.

CONTRAINTES STRICTES:
- L'audio √©nonce des lettres et des chiffres
- Le code contient UNIQUEMENT des lettres (a-z, A-Z) et des chiffres (0-9)
- Aucun symbole, espace ou caract√®re sp√©cial
- Longueur typique: 5-8 caract√®res

Transcris exactement ce qui est √©nonc√© dans cet audio.

R√âPONSE:
R√©ponds UNIQUEMENT avec le code captcha, rien d'autre.
Exemple: U42B84U

Code captcha:"""

    def _clean_response(self, response_text: str) -> str:
        """Nettoie la r√©ponse de Gemini"""
        import re

        # Supprimer tout sauf lettres et chiffres
        cleaned = re.sub(r'[^a-zA-Z0-9]', '', response_text.strip())

        return cleaned


def test_multimodal_solver():
    """Test du r√©solveur multimodal"""
    solver = MultimodalGeminiSolver()

    # Chercher les derniers fichiers captur√©s
    image_files = glob.glob("screenshots/captcha_image_*.png")
    audio_files = glob.glob("screenshots/captcha_audio_*.wav")

    if not image_files:
        print("‚ùå Aucune image captcha trouv√©e")
        print("   Lancez test_hybrid_captcha.py d'abord")
        return

    if not audio_files:
        print("‚ùå Aucun audio captcha trouv√©")
        print("   Lancez test_hybrid_captcha.py d'abord")
        return

    # Prendre les fichiers les plus r√©cents
    latest_image = max(image_files, key=os.path.getctime)
    latest_audio = max(audio_files, key=os.path.getctime)

    print("üéØ TEST MULTIMODAL GEMINI FLASH")
    print("=" * 50)
    print(f"Image: {latest_image}")
    print(f"Audio: {latest_audio}")
    print()

    # Test multimodal
    print("üî• Test 1: MULTIMODAL (Image + Audio)")
    result_multimodal = solver.solve_captcha_multimodal(
        latest_image, latest_audio)

    print("\nÔøΩ Test 2: IMAGE seule")
    result_image = solver.solve_captcha_image_only(latest_image)

    print("\nüéß Test 3: AUDIO seul")
    result_audio = solver.solve_captcha_audio_only(latest_audio)

    # Comparaison
    print("\nüìä COMPARAISON DES R√âSULTATS:")
    print("=" * 50)
    print("üî• Multimodal: '%s'" % result_multimodal)
    print("üñºÔ∏è Image seule: '%s'" % result_image)
    print("üéß Audio seul: '%s'" % result_audio)

    # Recommandation
    if result_multimodal:
        print("\nüí° RECOMMANDATION: Utiliser r√©sultat multimodal '%s'" %
              result_multimodal)
        return result_multimodal
    elif result_image:
        print("\nüí° FALLBACK: Utiliser r√©sultat image '%s'" % result_image)
        return result_image
    elif result_audio:
        print("\nüí° FALLBACK: Utiliser r√©sultat audio '%s'" % result_audio)
        return result_audio
    else:
        print("\n‚ùå √âCHEC: Aucune m√©thode n'a fonctionn√©")
        return None


if __name__ == "__main__":
    test_multimodal_solver()
